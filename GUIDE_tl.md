# Isang Patnubay sa GitHub Code Vault

## Panimula

Ang archive na ito, ang GitHub Code Vault, ay itinatag ng GitHub Archive Program, na ang misyon ay upang mapanatili ang bukas na mapagkukunan ng software para sa mga susunod na henerasyon. Maaari mong basahin ang isang taon mula ngayon, o isang libong, ngunit alinman sa paraan, inaasahan namin ang mga nilalaman nito, at marahil ang mismong konsepto ng bukas na mapagkukunan, ay kapaki-pakinabang sa iyo.

Pangunahin ito ay isang archive ng software. Ang software ay isang serye ng mga utos na ginamit upang makontrol ang mga pagkilos ng isang computer. Ang isang computer ay isang aparato na maaaring awtomatikong maisagawa ang mga pag-andar sa matematika nang mas mabilis kaysa sa isip ng tao na mayroon itong mga kapangyarihan na higit sa atin. Ang aming mga computer ay ginagamit upang matulungan ang galugarin ang mga lihim ng sansinukob, upang ikonekta ang lahat ng sangkatauhan sa isang hindi kilalang web ng impormasyon, upang manipulahin ang mga signal nang sapat upang maipadala ang mga tunog at detalyadong proyekto na gumagalaw ng mga imahe sa mga de-koryenteng screen, at upang makontrol ang napakalakas na makinarya na malayo lumampas sa parehong kapasidad at katumpakan ng paggawa ng tao.

Ang isang computer na walang software ay walang magagawa sa mga bagay na ito. Ang isang computer ay isang pambihirang at kamangha-manghang bagay, ngunit walang software, ang lahat ng kapangyarihan nito ay walang silbi. Ang layunin ng archive na ito ay upang maipasa ang alam namin tungkol sa software sa iyo.

Ang software ay isinulat bilang kumplikado ngunit madaling mabasa ng mga pagkakasunud-sunod ng mga utos, ang iba't ibang mga lasa na kung saan ay kilala bilang mga wika sa programming, dahil ang isang kumpletong yunit ng software ay madalas na tinatawag na isang programa. Ang mga programang ito ay pagkatapos ay na-convert sa binary wika ng mga bago at zero na ginagamit ng mga computer. Ang prosesong ito ay kilala bilang pag-iipon.

Dahil ang pinagsama-samang software ay napakahirap upang matukoy pabalik sa orihinal na form ng programa, na kilala rin bilang source code, posible para sa mga tao na panatilihing lihim ang orihinal na form at i-claim ang pagmamay-ari nito. Ang open source software ay hindi isang iba't ibang uri ng software, ngunit isang iba't ibang etos. Ang open source etos ay tumanggi sa lihim at pagmamay-ari. Ang mga bukas na mapagkukunan ng software na programa ay magagamit para sa anuman at lahat na nais gamitin ito, nang walang gastos, kaya maaari nilang pagbutihin ang mga programang iyon, o gamitin ang mga ito upang makabuo ng bago at mas mahusay.

Ang isang bukas na mapagkukunan ng proyekto ay ang kolektibong gawain ng isang organisasyong nag-aayos ng sarili na maaaring bilangin sa libu-libo. Ang akumulasyon ng lahat ng mga bukas na mapagkukunan ng software na naka-archive dito ay ang gawain ng isang komunidad ng maraming milyon-milyon. Habang ang ilang mga indibidwal ay maaaring magkaroon ng mga espesyal na karapatan sa loob ng anumang naibigay na proyekto, tulad ng kakayahang aprubahan o tanggihan ang mga iminungkahing pagbabago sa pinakabagong opisyal na bersyon ng source code, walang nagmamay-ari nito. Ang bawat tao ay may bawat karapatang kumuha at gumamit ng isang kumpletong kopya ng anumang bukas na mapagkukunan na proyekto sa anumang oras, nang walang gastos o parusa. Ito ay kilala bilang pagtatanggal ng isang proyekto.

Kapag maraming mga tao ang nagtatrabaho sa source code nang sabay-sabay, mahirap subaybayan at isama ang lahat ng kanilang mga pagbabago. Ang isang bukas na mapagkukunan ng proyekto na kilala bilang 'Git' ay nakatuon sa paglutas ng problemang ito. Pinagsasama nito ang isang kumpletong kasaysayan ng lahat ng mga pagdaragdag at mga pagbabago sa isang proyekto sa isang nilalang na kilala bilang isang repositoryo ng Git. Ang archive na ito ay mahalagang archive ng naturang mga repositori.

Ang archive na ito ay nilikha ng isang kumpanya na nagngangalang 'GitHub', na nagbibigay ng isang serbisyo na hinahayaan ang mga tao sa buong mundo na mag-imbak ng mga programang software na kanilang isinulat, subaybayan ang mga pagbabago sa mga programang ito, at makipagtulungan sa iba upang mapagbuti at mapalawak ang mga ito. Ginagamit ng GitHub ang mga serbisyo nito na magagamit nang libre sa mga developer ng pampublikong open source software. Mayroon itong sampu-sampung milyong mga ganyang gumagamit.

Ang sumusunod ay isang paglalarawan ng kung ano ang pinaniniwalaan namin na kailangan mong malaman at magkaroon upang magamit ang pinakamahusay na software archive na ito. Kung hindi mo alam o naiintindihan ang ilan o anuman dito, huwag mawalan ng pag-asa! Kasama rin namin ang isang gabay sa kung paano maisakatuparan ang mga kinakailangang ito. Kung sa anumang kadahilanan hindi mo magawa ang mga ito sa iyong sarili, kung gayon ang iyong mga inapo ay makakaya.

## Ano ang Kailangan mong Gamitin Ang Archive

Sa prinsipyo, ang kailangan mo lamang na ma-access ang mga nilalaman ng archive na ito ay isang mapagkukunan ng pag-iilaw at ilang uri ng magnifier. Gayunpaman, ang karamihan (kahit na hindi lahat) ng data nito ay naka-pack na mahigpit sa mga gulong ng pelikula sa isang naka-encode at naka-compress na form. Ang pagbabasa, pag-decode, at pag-uncompress ng data na ito ay mangangailangan ng maraming computation mismo. Sa teorya maaari itong gawin nang walang mga computer, ngunit magiging napakapapagod at mahirap.

Ang aming inaasahan ay hindi mo kailangan ang aming mga kahulugan ng software, computer, at iba pang mga termino. Inisip namin na mayroon kang sariling computer, marahil sa malawak na mas advanced kaysa sa amin, at marahil sa panimula ay naiiba na nai-archive. Kapag naiintindihan mo ang pangkalahatang-ideya at gabay sa ibaba madali mong mai-access ang lahat ng data.

Gayunpaman, posible na mayroon kang mas mababang mga computer sa amin, o kahit na walang mga computer. Sa kaso ng pangyayaring iyon, naghanda kami ng isang uncompressed, unencoded, human-read na reel ng data na tinawag nating Tech Tree. Ang Tech Tree ay naglalaman ng impormasyon tungkol sa aming mga pangunahing teknolohiya, aming mga computer, at aming software, sa pag-asa na sa paglipas ng panahon, magagawa mong magamit ang kaalamang ito upang muling likhain ang mga computer na maaaring magamit ang bukas na mapagkukunan ng software sa archive na ito.

## Anong nasa loob

Ang archive ay napakalaki - humigit-kumulang 24 trilyon na bait (ipinaliwanag sa ibaba) - dahil ito ay lubos na napapabilang at demokratiko. Maraming milyon-milyong mga tao ang gumawa ng software na kanilang isinusulat na magagamit sa lahat. Kasama sa archive na ito ang isang snapshot - iyon ay, isang solong kopya, sa isang solong sandali sa oras - ng lahat ng pampublikong software na aktibong nabubuo ng mga gumagamit ng GitHub. Nangangahulugan ito na nagsasama ito ng sampu-sampung milyong magkakahiwalay na mga repositori. Ang aming pag-asa ay ang malawak, demokratikong diskarte na ito ay magiging interes sa mga istoryador sa hinaharap.

Ang mga repositori na kasama sa archive na ito ay tinukoy nang puro sa kanilang huling oras ng paggawa, na nangangahulugang ang huling oras na na-update nila, at ang kanilang bilang ng bituin. (Ang mga gumagamit ng GitHub ay may kakayahang lahat na 'star' repositories, upang ipahiwatig na sila ay may interes o kabuluhan sa kanila.) Ang snapshot ay sinimulan noong 02/02/2020, iyon ay, sa ikalawang araw ng buwan ng Pebrero, sa sa taong 2020 ng kalendaryong Gregorian, bilang bilang natin. Ang mga repositori na kasama dito ay: lahat ng mga repositori na may anumang mga gawa sa loob ng nakaraang 80 araw; lahat ng mga repositori na may hindi bababa sa isang bituin na may anumang mga commits sa loob ng nakaraang 365 araw; at lahat ng mga repositori na may hindi bababa sa 250 mga bituin, hindi alintana kung kailan sila huling na-update.

Siyempre, hindi lahat ng mga repositori na ito ay pantay na mahalaga sa mga tuntunin ng kanilang impluwensya at dependencies. Ang Tech Tree ay nagsasama ng isang indeks at maikling paglalarawan ng mga pinaka makabuluhang mga repositori sa archive, at mga listahan na kung saan ang bawat reel ay maaaring matagpuan, upang mai-access sila nang hindi kinakailangang lumusot sa lahat ng milyun-milyong mga repositori na ito upang matukoy kung alin ang pinaka praktikal kapaki-pakinabang

## Isang Pangkalahatang-ideya ng Ang Archive

Ang archive ay binubuo ng 201 reels ng pelikula: isang "gabay na reel" ng nababasa na impormasyon at gabay ng tao, at 200 reels ng archive software. Ang bawat reel ay may kasamang 65,000 indibidwal na mga frame. Ang mga frame sa simula ng bawat reel, at ang mga frame ng gabay na reel, ay kasama ang teksto at mga imahe na nababasa ng tao. Ang lahat ng iba pang mga frame ng film ay binubuo ng digital data na naka-imbak sa isang visual form na kilala bilang QR code.

Ang digital data ay nangangahulugang data na naka-imbak sa binary format, ibig sabihin bilang 0 at 1s, dahil ang mga computer mismo ay binago - kinokontrol ng mga de-koryenteng signal na alinman sa "on" o "off", na naaayon sa 1 o 0 - at sa gayon ang data ng binary lubos na mas madali para sa mga computer na maunawaan kaysa sa iba pa.

Ang metadata na nababasa ng tao na nakaimbak sa simula ng bawat reel ay may kasamang impormasyon tungkol sa pelikula mismo, isang gabay sa QR encoding na ginamit, isang programa ng software upang mai-decode ito, at isang index. Inilista ng index ang pamagat, panimulang numero ng frame, at tseke para sa bawat file na nakaimbak sa reel na iyon.

Ang isang file ay isang solong magkakaibang data entity. Ang isang tseke ay isang natatanging halaga mula sa isang pagkalkula, na kilala bilang isang function ng hash, na tumatakbo sa buong nilalaman ng isang file, upang matiyak na ang mga nilalaman nito ay hindi nasira o nasira; ang hash function na ginamit sa archive ay kilala bilang 'SHA-1'.

Ang bawat QR code ay binubuo ng isang patlang ng maliliit na puti o itim na mga parisukat na sumasakop sa halos buong frame ng pelikula. Ginagamit namin ang mga QR code dahil ang mga ito ay mas compact at matatag kaysa sa nababasa na teksto ng tao. Ang isang QR code ay nag-decode sa binary data, i.e. isang serye ng mga bago at zero.

Ang pag-decode na ito ay lamang ang unang hakbang sa paggawa ng binary data na iyon sa makabuluhang impormasyon. Ito ay naka-compress na data, nangangahulugang na-compact na ito upang makatipid ng puwang, na katulad ng kung paano maaaring isulat ng isa ang "128xA" sa halip na isulat ang titik A 128 beses. Pagkatapos ma-decode, dapat itong ma-decompress.

Ang resulta pagkatapos ng decompression ay kilala bilang isang file ng archive: ang isang solong file na naglalaman ng buong nilalaman ng imbakan ng isang solong proyekto ng software. Karamihan sa mga repositori ay nagsasama ng maraming mga file, kaya ang file ng archive na ito ay tulad ng isang libro na naglalaman ng maraming magkakahiwalay na mga kabanata, o isang kahon na naglalaman ng maraming iba pang mga kahon. Sa pangkalahatan ito ay kapaki-pakinabang, kahit na hindi ganap na kinakailangan, upang i-unpack ang archive file sa mga file ng sangkap nito bago ma-access ang mga ito.

Sa wakas, ang bawat file na sangkap ay ang sariling hanay ng mga data ng binary, iyon ay, mga at zero. Ang isa ay maaaring magkaroon ng kahulugan ng data kung alam mo ang format nito. Halimbawa, sa format na kilala bilang 'UTF-8', ang pinaka-karaniwang format sa archive, ang mga at zero ay nahahati sa mga pangkat ng walong, na kilala bilang mga byte, ang byte 01000001 ay kumakatawan sa titik A; ang tatlong baitang 01101001 01101110 01110100 ay kumakatawan sa salitang int; at ang dalawang byte 11000011 10000011 ay kumakatawan sa liham Ã (A na may isang tilde accent sa tuktok.)

Ang proseso ng archival ng data na ito, ang mga binary file na naka-pack sa mga file na archive na unang na-compress at pagkatapos ay naka-QR-encode, ay malinaw na kumplikado kumpara sa simpleng pagsulat ng teksto na nababasa ng tao. Ang proseso ng unarchiving kakailanganin mong dumaan - QR upang mai-compress ang binary; naka-compress sa hindi naka-compress; archive file sa maraming mga file; ang mga file ng teksto sa teksto na mababasa ng tao - ay parehas na kumplikado. Iyon ay dahil ang pagiging kumplikado na ito ay nagbibigay-daan sa amin upang mag-imbak ng mas maraming data kaysa sa kung hindi man posible, sa isang medyo madaling mabasa ng computer na paraan.

Kung ang pagiging kumplikado na ito ay mahirap at magastos para sa iyo, humihingi kami ng tawad, ngunit ang aming inaasahan ay na, kung ito ang kaso, ang gabay na ito at ang nababasa ng Tech Tree, ay magpapagaan ng pagiging kumplikado, at maaaring maging mas kapaki-pakinabang sa iyo kaysa sa archive na mga nilalaman, hindi bababa sa hanggang sa ang iyong mga computer ay sapat na advanced na ang pagiging kumplikado ng data ng archive ay madaling harapin.

## Mga File, Direktoryo, Repositori, at Mga Format ng Data

Maaaring magturo upang talakayin kung paano lohikal na nahahati ang archive. Sa partikular, ang isang talakayan ng mga file, direktoryo, at mga format ng data ay malamang na maging kapaki-pakinabang.

Ang isang file ay isang koleksyon ng data na pinagsama-sama sa isang magkakaugnay na nilalang na may isang solong pangalan: mag-isip ng data bilang buhangin, at isang file bilang isang uri ng bag na maaaring humawak ng buhangin, at buhangin lamang. Ang isang direktoryo ay isang koleksyon ng mga file: isipin ito bilang isang uri ng bag na maaari lamang humawak ng iba pang mga bag. Kasunod ng talinghagang ito, ang bawat repositoryo ay binubuo ng isang panlabas na direktoryo, na kilala bilang direktoryo ng ugat, na naglalaman ng isang bilang ng mga file at / o isang bilang ng mga direktoryo. Ang bawat direktoryo ay maaaring, sa turn, ay naglalaman ng parehong mga file at direktoryo mismo.

Ang istraktura na ito ay ginustong dahil ang mga file na naayos sa mga grupo ay mas madali upang gumana sa isang solong koleksyon ng mga file. Ang identifier ng isang partikular na file sa loob ng panlabas na direktoryo ay binubuo ng mga pangalan ng lahat ng mga direktoryong nakapaloob dito, na nagsisimula sa ugat, na sinusundan ng sariling indibidwal na pangalan, na may isang / character sa pagitan ng bawat pangalan. Halimbawa, ang isang file na nagngangalang README.md sa direktoryo ng ugat ay makikilala bilang /README.md at isang file na nakilala bilang /public/www/index.html ang magiging file index.html sa direktoryo ng 'www' sa loob ng ' direktoryo ng publiko sa loob ng direktoryo ng ugat.

Ang bawat repositoryo naman ay may dalawang pangalan, na pinaghiwalay ng isang divider, na sa archive ay isang _ o salungguhit na karakter. (Makasaysayang ito ay isang / o slash, ngunit ginagamit din ito upang ipahiwatig ang isang direktoryo, kaya ginagamit namin _ para sa kalinawan.) Ang unang pangalan ay ang account ng GitHub na nagmamay-ari ng imbakan; ang pangalawa ay ang pangalan ng indibidwal na imbakan. Ang kumbinasyon ng mga tagatago at mga tagatukoy ng file ay maaaring magamit upang natatanging kilalanin ang isang indibidwal na file sa archive. Halimbawa, ang file na 'package.json' sa direktoryo na 'web' sa repositoryo 'ykarma' sa loob ng GitHub account 'rezendi' ay maaaring natatanging kinilala bilang /web/package.json sa rezendi_ykarma sa archive.

Ang iba't ibang uri ng mga file ay may iba't ibang layunin. Ang archive ng GitHub ay binubuo ng higit sa mga file ng teksto, na nangangahulugang mga file na ang data ay nilalayong kumakatawan sa nakasulat na wika. Karamihan sa software ay nakasulat sa mga file ng teksto na naglalaman ng mataas na nakabalangkas na teksto na kilala bilang source code. Ang isang espesyal na programa na kilala bilang isang tagatala ay nag-convert na maaaring mabasa ng mapagkukunan ng code ng tao sa mga nababasa na computer na mga tagubilin na kilala bilang pinagsama-samang code o code sa makina.

Ang mga file na hindi mga file ng teksto, tulad ng mga file na kumakatawan sa mga visual na imahe o naglalaman ng pinagsama-samang code, ay madalas na tinutukoy bilang mga binary file. Sa kasamaang palad ito ay isang nakaliligaw na term, dahil ang mga file ng teksto ay nasa huli at 1s din. Tumutukoy kami sa mga file na hindi mga file ng teksto bilang mga file na hindi teksto.

Maraming mga paraan upang kumatawan sa nakasulat na wikang pantao gamit ang 1 at 0s. Para sa makasaysayang mga kadahilanan, ang karamihan sa code ng mapagkukunan ay orihinal na isinulat sa kung ano ang kilala bilang Latin script. Ang script ng Latin ay may 26 pangunahing mga character na ginagamit upang kumatawan sa mga madaling salita, na ang bawat isa ay may dalawang anyo, itaas na kaso at mas mababang kaso. Mayroon din itong 10 mga numero upang kumatawan sa mga numero. Ang script ng Latin, kasama ang iba pang iba pang nauugnay na mga simbolo na ginamit upang magpahiwatig ng istraktura at iba pang mga konsepto, ay naka-encode sa 1s at 0s sa isang format na kilala bilang 'ASCII', na maaaring kumatawan sa 128 iba't ibang mga character at para sa makasaysayang dahilan ay nangingibabaw sa karamihan ng software sa loob ng maraming taon .

Gayunpaman, ang script ng Latin ay isang maliit na subset lamang ng maraming mga paraan kung saan ipinahayag ng mga tao ang kanilang sarili sa nakasulat na wika. Upang suportahan ang iba pang mga script, habang pinapayagan din ang lahat ng software na isinulat upang magamit ang ASCII upang magpatuloy sa pagtatrabaho nang walang mga pagbabago (isang konsepto na kilala bilang pabalik na pagkakatugma), isa pang format ng data na kilala bilang 'UTF-8' ay ipinakilala.

Ang ASCII ay nananatiling pinaka-karaniwang format ng source code. Ang bawat reel ng archive na ito ay may kasamang gabay sa mga character na ASCII. Ang ASCII ay isang subset ng UTF-8, na ang ibig sabihin, lahat ng mga pag-encode ng ASCII ay mga encode ng UTF-8. Bukod pa rito ang gabay na reel ay naglalaman ng isang detalye ng lahat ng mga character ng UTF-8. Halos lahat ng mga file ng teksto sa archive na ito ay dapat na naka-encode bilang UTF-8.

Kasama sa mga file na hindi teksto ang mga file na nilalayong kumatawan ng mga imahe at mga format na dokumento. Ang isang malawak na ginagamit na kombensyon ay para sa mga pangalan ng file na magtatapos sa isang '.' karakter na sinusundan ng isang pang-akit na nagpapahiwatig ng uri ng file. Halimbawa, ang isang file name na nagtatapos sa .jpg ay malamang isang JPEG image file; ang isa na nagtatapos sa .PNG ay malamang na isang file ng imahe ng Portable Network Graphic; at isa na nagtatapos sa .pdf isang file na Format ng Portable na Dokumento.

Walang solong suffix na nagpapahiwatig ng mga file na teksto. Sa halip, para sa source code, ang posibilidad ay mas malamang na ipahiwatig kung aling mga programming o markup language ang code ay nakasulat sa. Ang mga programming at markup na wika ay ilalarawan nang mas detalyado sa ibaba.

## Paano Makukuha Ang Mga Nilalaman ng Archive

Dito bibigyan kami ng isang pangkalahatang ideya kung paano i-unpack ang isang partikular na naka-archive na imbakan sa iba't ibang mga file ng nasasakupan. Muli, ang prosesong ito ay binubuo ng:

1. Pagkilala sa mga tukoy na gulong at mga frame kung saan nai-archive ang data ng imbakan.

2. Ang pag-decode mula sa mga QR code, ang mga patlang ng itim, puti, at kulay-abo na mga pixel sa mga frame, sa isang binary file, isang pagkakasunud-sunod ng (hindi bababa sa libu-libo, at madalas milyon-milyong) 1s at 0s.

3. Pag-alis ng binary file sa isang mas mahaba, hindi naka-compress na archive file.

4. Pag-alis ng file ng archive sa hiwalay na mga subfile na nilalaman nito. Pansinin subalit ang data ng archive ay karaniwang naiintindihan, kahit na magulo, kahit na ang hakbang na ito ay tinanggal.

5. Sa wakas, ang pag-convert ng bawat isa sa mga subfile - ang kanilang mga sarili na mga pagkakasunud-sunod ng 1 at 0 na maaaring saklaw mula sa medyo maikli hanggang sa napakatagal - sa mga nakasulat na character, kung ang mga ito ay mga file na teksto.

### Kinikilala ang tukoy na reel at mga frame kung saan nai-archive ang data ng imbakan

Ang bawat reel ng pelikula ay nagsisimula sa isang pinuno ng walang laman na pelikula, at pagkatapos ay ang Zero Reference Frame, na binubuo ng isang solidong itim na parihaba sa isang sulok ng isang kung hindi man walang laman na frame. Ang susunod na nababasa na frame ng tao ay ang Control Frame, na may impormasyon tungkol sa reel. Kasunod nito ay ang Talahanayan ng mga Nilalaman, na kung saan ay may kasamang listahan ng mga File ng Mga Data ng Gumagamit.

Ang bawat imbakan sa reel na ito ay isa sa mga File ng Mga Data ng Gumagamit. Kasama sa listahan ang isang natatanging ID, isang file ID at isang pangalan para sa bawat isa sa mga file na iyon. Halimbawa, ang CPython account ng Python account ay maaaring may nakalista na file ID na nakalista bilang 12345, at ang pangalan na nakalista bilang python_cpython.tar.

Ang pagsunod sa listahan ng Mga Data ng Gumagamit ng Data ay isang listahan ng mga Digital na Mga Lugar ng Data. Kasama sa listahang ito ang file ng ID, isang panimulang frame, isang simula, isang frame ng pagtatapos, at isang pagtatapos. Kaya, gamit ang hypothetical CPython halimbawa, ang item sa listahang ito kasama ang ID 12345 ay maaaring magkaroon ng isang panimulang frame ng 054321, isang simula ng 03210321, isang pagtatapos na frame ng 054545, at isang pagtatapos ng 12321232.

Nangangahulugan ito, upang makuha ang data ng CPython: Pumunta sa frame na 54321 ng reel ng film na ito. I-decode ang lahat ng mga frame mula sa simula ng frame, 54321, hanggang sa dulo ng frame, 54545, sa mga halaga ng binary, sa pamamagitan ng inilarawan sa ibaba. Bibigyan ka nito ng 225 na piraso ng data na bilang mula sa 54321 hanggang 54545, na magsisimula sa isang hanay ng mga blangkong piraso na walang data. Itapon ang unang 3210320 byte sa unang hindi blangkong piraso ng data. Idagdag ang lahat ng mga "gitna" na mga piraso ng data, sa pagkakasunud-sunod. Sa wakas, idagdag ang unang 12321232 byte mula sa huling piraso ng data, 54545. Ngayon ay natipon mo na ang kumpletong imbakan ng CPython, bilang isang solong naka-compress na archive file.

### Pag-decode mula sa mga QR code sa isang binary file

Ang mga detalye ng kung paano mabasa ang mga frame ng pelikula sa binary data ay matatagpuan sa nababasa na Impormasyon ng Representasyon ng Kinakatawan ng tao na matatagpuan kasunod ng Talahanayan ng Mga Nilalaman sa simula ng bawat reel ng pelikula sa archive. Ang impormasyong ito ay matatagpuan sa bawat reel upang, kahit na ang isang indibidwal na reel ay nahihiwalay mula sa archive, posible pa ring matukoy ang mga nilalaman nito. Kasama sa Impormasyon sa Kinakatawan

1. Isang Patnubay sa GitHub Archive Program (ang dokumentong ito)

2. Ang index ng deskripsyon ng GitHub, isang listahan at maikling paglalarawan ng lahat ng mga repositori sa reel na ito

3. paglalarawan ng Impormasyon sa Representasyon

4. Digital Preservation at Paano Kunin ang Data, isang pangkalahatang-ideya ng mga detalye sa pagkuha ng data

5. paglalarawan ng Katamtamang Imbakan

6. Teknolohiya ng Pagkuha ng Data

7. Pangkalahatang Pag-iingat ng Reel Structure (reel format)

8. Pangkalahatang paglalarawan ng format na Frame ng 4K

9. Pag-unbox ng paglalarawan ng library (para sa mga QR code)

10. Unboxing code ng mapagkukunan ng library

11. Pagtukoy ng format ng data ng ASCII

12. C pagtutukoy sa wika ng programming

13. TAR archive file source code

14. PDF source code

15. Ang pagtutukoy ng format ng file ng XZ (para sa compression / decompression, inilarawan sa ibaba)

Ang ikaanim ng mga item na iyon, ang dokumento ng Data Retrieval Technology, ay naglalarawan ng mga kinakailangan at proseso upang magamit ang isang scanner upang makuha ang data sa isang solong digit na naka-encode na frame ng pelikula at gawing isang form na matapat sa pagsusuri ng computer. Ang ikawalo sa kanila, ang paglalarawan ng Generic 4K Frame format, ay nagbibigay ng teknikal na impormasyon, kabilang ang source code, na kinakailangan para sa isang computer na kumuha ng nasabing imahe at mai-convert ito sa binary data.

Posible ito, sa prinsipyo, upang mai-convert ang isang imbakan mula sa data na naka-encode ng QR hanggang sa data ng binary nang hindi gumagamit ng isang computer. Gayunpaman, napakahirap ito at marahil ay nangangailangan ng isang malaking pagsisikap mula sa isang maayos na organisasyong pamayanan sa maraming linggo, kung hindi buwan o taon. Dahil ang mga nilalaman ng mga repositori ay software na inilaan upang tumakbo sa isang computer, ang kanilang paggamit sa kawalan ng isang computer ay magiging minimal sa pinakamainam.

Kung ang mga nagmamana ng archive na ito ay walang mga computer, dapat nilang panatilihing buo at ligtas ang archive hanggang sa magawa nila. Ang isang layunin ng nabasang Tech Tree ay makakatulong upang mapabilis ang pag-unlad ng mga teknolohiya at computer kung sakaling ito. (Ang iba pang layunin nito ay upang mai-codify ang aming teknolohiya at ang pag-unlad nito para sa mga hinaharap na istoryador.)

### Binubuksan ang file ng archive sa hiwalay na mga subfile na nilalaman nito

Ang binary file para sa bawat repositoryo ay nasa isang format na kilala bilang TAR, para sa Tape Archive. Ang isang file ng TAR ay mahalagang binubuo sa pamamagitan ng pagpapangkat ng isang bilang ng mga file nang magkasama sa pagkonekta sa dulo ng isa hanggang sa simula ng susunod, tulad ng pag-tap ng mga indibidwal na piraso ng papel nang magkasama sa isang solong scroll. Ang isang file ng TAR ay maaaring magsama ng anumang bilang ng mga file, ng anumang sukat, na nahahati sa anumang bilang ng mga direktoryo at subdirectory.

Ang bawat subfile sa loob ng isang file ng TAR ay prefaced ng isang 512-bait na header record, na kumikilos tulad ng tape sa metaphor ng scroll. Ang talaang header na ito ay naglalaman ng impormasyon tungkol sa file, tulad ng pangalan at laki nito. Ang pagtatapos ng archive ay ipinahiwatig ng hindi bababa sa dalawang magkakasunod na mga bloke ng 512-bait.

Dahil ang mga file ng TAR ay mahalagang koleksyon lamang ng mga file na may mga tala sa teksto sa pagitan nila, kung ang isang file ng TAR ay naglalaman ng lahat ng mga file ng teksto, maaari itong gamutin bilang isang file ng teksto mismo. Kung naglalaman ito ng isang pinaghalong, maaari itong tratuhin bilang isang file ng teksto na naglalaman ng isang halo ng nakabalangkas, makabuluhang teksto (ang mga tekstong bumubuo ng teksto) at hindi maintindihan na gibberish (ang mga hindi mga file na hindi teksto.)

Posible upang ihiga ang mga file ng TAR sa loob ng mga file ng TAR, isang lalagyan sa loob ng isa pa, at ito ay kung paano naka-imbak ang karamihan sa aming naka-archive na data. Para sa anumang naibigay na imbakan, ang panlabas na TAR file ay maglalaman ng hindi bababa sa:

* Ang isang solong hindi naka-compress na metadata file na tinatawag na META, na kinabibilangan ng repository name, account name, paglalarawan, wika, star count, at fork count
* isang naka-compress (tingnan sa ibaba) file na nagngangalang COMMITS, na kasama ang log ng mga pagbabagong ginawa sa repository sa paglipas ng panahon
* isang file na nagngangalang repo.tar.xz, isang naka-compress na TAR file na naglalaman ng aktwal na mga nilalaman ng pag-iimbak

Ang iba pang mga metadata, tulad ng wikis, gh-pages, isyu, at paghiling ng mga kahilingan, ay maaari ring isama bilang hiwalay na mga naka-compress na file.

Ang mga tiyak na detalye ng mga file ng TAR, at ang software upang mai-encode at mabasa ang mga ito, ay matatagpuan sa Impormasyon ng Representasyon sa bawat reel ng archive.

### Pag-alis ng mga naka-compress na file sa nababasa, hindi naka-compress na mga file

Upang maisama ang maraming mga repositori at mas maraming data hangga't maaari, ang karamihan sa data ay na-compress. Ang kompresyon ay nangangahulugan ng paggamit ng isang maliit na halaga ng data upang kumatawan sa isang mas malaking halaga, sa pamamagitan ng paggamit ng mga pattern at pag-uulit sa mas malaking halaga. Halimbawa, sa halip na isulat ang karakter ng siyam na beses sa isang hilera, isusulat lamang ng isa ang naka-compress na teksto 9a, kung ang isang tao ay tiwala na maunawaan ng mambabasa na ang 9a ay nangangahulugang ang hindi naka-compress na teksto aaaaaaaaa.

Ang mabisang algorithm ng compression ay mas kumplikado kaysa sa, ngunit naaangkop ang parehong prinsipyo. Ang archive na ito ay gumagamit ng isang programa ng compression na kilala bilang 'XZ', na siya namang gumagamit ng isang algorithm na kilala bilang 'LZMA'. Ang pangalawang file ng data sa bawat reel ay naglalaman ng source code at dokumentasyon para sa XZ sa isang solong hindi naka-compress na TAR archive file, na inilarawan sa ibaba. (Ang unang file ng data ay naglalaman ng Universal Declaration of Human Rights sa bawat magagamit na nakasulat na wika ng tao.)

Pinagsasama ng LZMA ang kilala bilang isang 'LZ77' algorithm at "range encoding". Pinalitan ng LZ77 ang paulit-ulit na data na may mga sanggunian sa mga nakaraang paglitaw ng data na iyon. Halimbawa, upang matindi ang labis na pagkakamali, kung ang isang 80-bait na parirala ay lilitaw nang dalawang beses, 400 byte nang hiwalay, sa pangalawang pagkakataon, ang algorithm ay mahalagang pinagsama ang data sa pamamagitan ng pagsasabi na "ulitin ang 80 byte mula sa 400 byte na nakalipas". Saklaw ng pag-encode ng saklaw ang isang buong mensahe sa isang solong napakahabang bilang, na kung saan ay maaaring mai-encode.

Ang mga tiyak na hakbang ng algorithm na gagamitin upang mabawi ang data ay inilarawan ng XZ source code na nilalaman sa pangalawang data file sa bawat reel. Bagaman posible ang teoretiko na ma-decompress sa pamamagitan ng kamay, muli, ito ay magiging isang labis na oras- at proseso ng masigasig na paggawa. Sa pagsasagawa, tatawagin ang isang nagtatrabaho na computer.

### Pag-convert sa bawat indibidwal na file sa mga nakasulat na character

Ang sangkatauhan ay gumamit ng maraming mga nakasulat na character sa loob ng millennia. Ang pag-encode na ginamit upang kumatawan sa mga character na ito bilang 1 at 0 sa loob ng archive na ito ay kilala bilang 'UTF-8'. Ang isang solong character na UTF-8, i.e. isang solong nakasulat na simbolo, ay maaaring sakupin kahit saan mula sa 1 hanggang 4 na baitang ng binary data.

Para sa makasaysayang mga kadahilanan, dahil sila ang pinaka-malawak na ginagamit sa oras at rehiyon kung saan at kailan nagsimula ang pag-unlad ng software, ang isang pangkat ng mga character (at konsepto) na kilala bilang 'ASCII' ay pinaka mahusay na naka-encode, sa 1 bait bawat character. Anumang bagay na hindi ASCII ay naka-encode bilang 2 o higit pang mga byte bawat character. Karamihan sa mga file ng teksto sa archive na ito ay ASCII, ngunit ang isang malaking bilang ay hindi. Marami pa ang magiging karamihan sa ASCII na may paminsan-minsang mga character na hindi ASCII.

Ang detalyadong mga detalye ng ASCII ay matatagpuan sa Impormasyon ng Representasyon sa bawat reel ng archive. Ang detalyadong mga pagtutukoy ng UTF-8 ay matatagpuan sa reel ng gabay. Ang unang file ng data sa bawat reel ng archive ay naglalaman ng teksto ng Universal Declaration of Human Rights sa bawat magagamit na nakasulat na wika ng tao. Ito ang magsisilbi bilang isang tool sa pagsasalin at bilang isang halimbawa ng ASCII at UTF-8.

## Mga Uri ng mga File

Maraming iba't ibang mga uri ng mga file ng teksto, na nilikha para sa iba't ibang mga kadahilanan. Ang pangunahing uri dito, ang dahilan ng umiiral na archive na ito, ay ang source code. Ang source code ay napaka siksik, sobrang nakabalangkas na teksto, kung saan ang mga simbolo tulad ng '{' at ';' may malaking kahalagahan.

Ang pangunahing bagay tungkol sa source code ay na ito ay nakasulat na babasahin ng mga compiler. Dahil ang mga compiler ay software, ang isa pang paraan ng pagbigkas nito ay ang source code ay isinulat upang mabasa ng mga computer. Ang mabuting code ay nakasulat din upang ang iba pang mga tao, kung sila ay may kasanayan at may edukasyon sa larangan ng software, ay maiintindihan ito; ngunit tama lamang ito kung maiintindihan ito ng isang tagatala.

Ang compiler na iyon ay, sa turn, sa pamamagitan ng mga kumplikadong mga pagkakasunud-sunod na inilarawan sa Tech Tree, i-convert ang source code sa mga pagkakasunud-sunod ng mga at mga zero na magiging sanhi ng computer upang maisagawa ang mga pag-andar at mga aktibidad na inilarawan ng code. Upang kumuha ng isang napaka-simpleng halimbawa, ang linya ng code

_for (int i = 0; i <5; i ++) {} _

ay mai-convert ng tagatala sa isang serye ng mga tagubilin sa binary na pinapakain sa computer, na magiging sanhi ng isang maliit na bahagi ng computer, na tinatawag na isang rehistro, upang itakda ang halaga nito sa 0, at kasunod na dagdagan ang halagang iyon sa 1, 2, 3, at pagkatapos ay 4. (Hindi ito inilaan bilang isang halimbawa ng kapaki-pakinabang na code; ito ay isang paglalarawan lamang ng maraming-layered na proseso ng paggawa ng source code sa pagpapatakbo ng software.)

Ang iba pang mga uri ng mga file ng teksto, tulad ng JSON, XML, at HTML, ay ginagamit upang mag-imbak ng data (kumpara sa mga utos) para sa mga computer. Sa pangkalahatan ay nababasa din sila ng mga tao, bagaman ang kanilang mga nakaayos na mga format ay nagpapahirap sa kanila na basahin kaysa sa hindi gaanong nakaayos na texttelling na teksto tulad ng file na ito.

Karamihan sa iba pang mga uri ng mga file na teksto ay inilaan na sa wakas ay basahin ng mga tao. Ang ilan ay simple, kadalasang hindi nakaayos na teksto, tulad ng file na ito na kasalukuyang binabasa mo. Ang isang uri na nakatagpo ka nang malawak sa archive ay ang Markdown, na signified ng extension ng .md sa isang file, na kung saan ay isang uri ng intermediate form na nilalayong mababasa ng mga tao sa kanilang hilaw na anyo at din, sa parehong oras, nakabalangkas upang maaaring i-format ng mga computer ang mga ito sa mas visual na nakakaakit at kapaki-pakinabang na mga layout. Karamihan sa mga repositori sa archive na ito ay may isang file na README.md Markdown, na sa pangkalahatan ay inilaan bilang isang paunang pagpapakilala sa repositoryo, na naglalarawan kung ano ito, kung bakit ito umiiral, at kung paano gamitin ito.

Ang isang maikling pangkalahatang-ideya ng mga pinaka-karaniwang anyo ng mga di-text na mga file ay maaaring maging kapaki-pakinabang. Ang pinagsama-samang code ay hindi teksto. Ang mga file ng JPG at PNG ay nag-encode ng mga imahe sa digital format, at ang MP3 at WAV encode audio. Ang mga file na PDF ay nag-encode ng mga dokumento na may tumpak, perpektong pag-format. At ang mga file ng ZIP at TAR, tulad ng nabanggit nang una, ay mga file ng lalagyan na maaaring kabilang ang isa pang maraming mga file.

## Mga Wika ng Tao at Programming Languages

### Mga Wika sa Tao

Mayroong libu-libong mga nakasulat na wika na ginagamit ng sangkatauhan ngayon, at higit pang mga sinasalita na wika. Karamihan sa mga ito ay ginagamit lamang ng medyo maliit na populasyon, ngunit may hindi bababa sa dalawampu't mga wika na ginamit bilang una o pangalawang wika ng hindi bababa sa 60 milyong tao.

Ang pinakalawak na ginagamit na wika sa mundo ay Ingles at Intsik. Para sa mga makasaysayang kadahilanan, sa maraming taon na ang karamihan sa pag-unlad ng software ay naganap sa mga bansang nagsasalita ng Ingles, kaya sa isang panahon, ang Ingles ay naging default na wika ng software. Karamihan sa mga wikang programming ay gumagamit ng mga salitang Ingles sa kanilang syntax. Ito ang wika kung saan isinulat ang gabay na ito sa archive.

Hindi ginagarantiyahan na ang mga nagmamana ng archive na ito ay malalaman ang Ingles, bagaman tila ang isang partikular na malamang na wika ay magtatagal nang walang hanggan. Kung sakaling ang ilang patnubay sa ibang mga wika ay kapaki-pakinabang, kasama namin ang higit sa 500 magagamit na mga pagsasalin ng Universal Deklarasyon ng Human Rights bilang isang hindi naka-compress na UTF-8 file sa simula ng bawat reel, at din sa loob ng Tech Tree. Ang deklarasyong ito ay isang listahan ng mga karapatan at kalayaan ng bawat indibidwal na tao sa ating panahon, na hindi kailanman dapat makuha.

### Mga Programming Languages

Ang mga wikang nagrograma ay ang mga ginagamit ng tao upang makipag-usap ng mga tagubilin sa mga computer. Ang mga ito ang mga wika kung saan ipinahayag ang software. Ang iba pang (bihasa) na mga tao ay dapat ding basahin ang software na nakasulat sa mga wika sa programming, ngunit iyon ay isang pangalawang layunin.

Ang isang wikang programming ay isang hanay ng mga paunang natukoy na mga elemento, na karamihan sa mga ito ay mga salita, na maaaring ayusin sa isang nakaayos na paraan upang magturo sa isang computer upang maisagawa ang tinukoy na aksyon sa tinukoy na paraan. Ang isang koleksyon ng mga naturang tagubilin ay kilala bilang isang programa, o bilang source code. Ang source code ay mahalagang software sa isang nagyelo, nakasulat na form.

Ang mga programa ay karaniwang nahahati sa mga hakbang na may discrete, na kilala bilang mga pahayag, na siya namang pinagsama-sama sa mga koleksyon na kilala bilang mga function. Ang isang buong programa ay maaaring nilalaman sa isang solong file, o maaaring kumalat sa libu-libo.

Mayroong daan-daang iba't ibang mga wika sa programming, na kumakalat sa maraming iba't ibang mga form, pamamaraang, at pilosopiya. Ang ilan ay natipon sa hiwalay na mga binary file, na pagkatapos ay pinaandar; ang ilan, na kilala bilang mga "kahulugan" na wika, ay epektibong pinagsama at pinapatakbo nang sabay-sabay, nang walang pansamantalang yugto. Karamihan sa mga modernong wika na programa ay nagsasama ng mga aklatan ng mga paunang nakasulat na pag-andar, at ang gayong mga aklatan ay maaaring masigla at masalimuot. Ang ilan sa mga pinakatanyag na wika ng programming ngayon ay kinabibilangan ng:

- C, isa sa pinakaluma at pinakamabilis, pinaka-unibersal, at pinakamalakas na wika, simple sa ilang mga paraan ngunit medyo limitado sa iba, at hindi palaging madaling maunawaan, madaling basahin, o madaling matutunan.

- C ++, isang mas kumplikado, abstract, at malakas na ebolusyon ng C.

- C #, isang karagdagang ebolusyon na naipon hindi sa binary code ng code ngunit isang kahulugan na "runtime".

- Ang Java, na kung saan ay katulad ng (ngunit tinukoy) C #, ay marahil ang pinakapinakagamit na wika ngayon.

-   JavaScript, quite unlike Java despite the similarity in name, and also known as 'ECMAScript', is a language initially used wholly within a web browser, i.e. a program which fetched, interpreted, and displayed data from a remote computer known as an Internet server; today, though, it is widely used on those servers as well.

-   TypeScript, a form of JavaScript with stricter rules so that errors, also known as bugs, are less likely to find their way into programs.

-   Python, an elegant language popular among scientists, both powerful and a good first language.

-   Ruby, an intuitive language whose statements often read almost like written English.

-   Go, a simple, powerful language which especially excels at parallelized programs, i.e. programs written such that multiple functions run independently at the same time.

-   Swift, a new language used to write for the phones and other devices used by a billion people.

-   Rust, intended as a replacement for C, one which makes dangerous bugs far less likely.

-   PHP, a straightforward language used for Internet servers.

-   Lisp, a very old language with a fundamentally different, function-first approach to programming.

-   SQL, a very different kind of language used to fetch data from structured and highly efficient stores of data known as databases.

-   Assembler (or assembly), a very cryptic, limited, but fast and powerful family of languages wherein there is a direct relationship between the language constructs and the machine code of the computer in question; it may be considered half-compiled code.

## Development, Dependencies, and Open Source

### Development

The process of taking a single, simple source code file and converting it into electrical impulses within a computer is extremely complex. We deal with this complexity using layers of abstraction. An abstraction known as an instruction set allows the machine code output from a single compiler to be used on many different kinds of computers. An author of source code does not usually need to know or care what kind of computer, or even what instruction set, will be used to run that code; this is abstracted out by the compiler.

Modern software is, in turn, much more complex than a single author working on a single program for a single computer. It consists of many authors working on many files within a single project, simultaneously, often using multiple programming languages. Furthermore, every project depends on other, separate, self-contained projects as tools and/or components, while these projects are themselves actively being worked on, and are in turn dependent on yet other projects. Making all these moving parts work together elegantly and efficiently is the challenge of modern software development.

When multiple source code authors, also known as software developers, work on a single project, each has their own computer, and a copy of the entire project on their computer. If they each make changes, then each has a different version of the same project. The process of reconciling multiple versions of a project is known as version control. It is managed by version control software; in this archive, by software called Git, after which GitHub itself is named. Every repository in this archive is a Git repository.

Git can automatically merge different versions of software together into one coherent form with minimal human intervention required. Git also keeps a complete history which allows you to roll back to a previous version as and when needed. However, in order to save space, this archive's repositories generally do not include Git histories.

When multiple developers take a project on multiple different paths simultaneously, this is known as branching a project, and those paths are known as branches. The agreed-upon main branch of a project is known as the trunk, or the master branch. Git provides a facility developers can use to summarize the differences between two branches and propose joining theirs into the other's. This is known as a pull request. Modern software development consists largely of branching a project, writing or editing the software on your branch, and, when finished, submitting a pull request for your work to be reincorporated back into the master branch.

### Dependencies

Essentially every programming language supports building upon the work of others. Without re-using others' work, every project would be enormously more difficult, and vastly slower, and vanishingly few projects would ever see actual use in the real world.

If project A needs to include project B in order for A to do its work, then A is known as dependent on project B, and B is known as a dependency of project A. A can have many dependencies, each of which can have many dependencies of their own, and so forth. Furthermore, each dependency is for a particular version, or range of versions, of a given project. The full itemization of all of a project's multiple layers of dependencies is known as its dependency tree.

Generally, dependencies are itemized inside source code files, usually at the very top, and each time the compiler or interpreter finds a dependency, it looks for it in a set of predefined directories. Because the dependency tree for a project can be very complex, it is sometimes itemized in its entirety in a single file within a project known as a package list. For instance, Ruby projects may have a Gemfile for this purpose, and JavaScript projects may have a package.json file. This allows a kind of tool known as package management software to fetch all the dependencies for a project at once, from one or more Internet servers.

In the case of this archive, it is likely that the dependencies for any given project exist elsewhere in the archive. In order to find a dependency in the archive, one must first discover the name of the dependency in the source code or the package list, the exact details of which vary by language and framework, and then use the master index in the guide reel, or, in its absence, the indexes at the front of each reel, to determine on which reel and frame(s) the repository in question can be found.

### Open source

Since running a program on a computer requires only the compiled machine code, it is possible to distribute that while keeping the source code secret. This is known as the closed source model. In the very early days of computing, source code was usually distributed along with its machine code, but subsequently, as software became a profitable industry, the closed source model became more common.

It has since been learned that making source code public, for anyone to copy, branch, and improve upon, is a far more effective approach to software development. More people who can read a project's source code means more people to identify possible needs and useful new features, more people who understand the project enough to contribute to it, more people who might spot bugs and submit fixes, and more people to test and verify that new code works.

In general, closed source leads to smaller, insular, fragmented communities who struggle to find and adopt new and better ideas. Open source leads to large, interconnected communities, each helping one another's projects grow and flourish and succeed, using each others' work as dependencies and/or reusing their code, and learning from one another. Open source software is a toolkit for the collective use of all humanity, and the more and better tools we have, the faster and better we can progress as a species.
